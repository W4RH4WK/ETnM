% vim:set spell tw=79:

\documentclass[article]{uibk}
\title{Exploitation Techniques and Mitigations}
\author{Alex Hirsch \and Patrick Ober}
\date{2016-01-31}

\usepackage{wrapfig}
\newminted{nasm}{
    fontsize=\scriptsize,
    frame=leftline,
    framesep=2mm,
    autogobble,
    linenos}
\newmintedfile{nasm}{
    fontsize=\scriptsize,
    frame=leftline,
    framesep=2mm,
    autogobble,
    linenos}

\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning,shapes.geometric}
\usetikzlibrary{shapes.multipart}

\begin{document}

\maketitle

\section*{Abstract}
\label{sec:abstract}

\begin{quote}
    When a buffer overwrites a pointer\dots\enspace The story of a restless
    mind.
\end{quote}

Exploiting binaries is an extremely broad topic with many specialized
techniques for even the most exotic scenarios. In this writeup we will take a
narrow look at exploiting \texttt{printf} with crafted format strings first and
follow up with an introduction about buffer overflows. Mitigation mechanisms
will be disabled at first and enabled one by one --- discussing them when they
are put into place. The buffer overflow will be augmented to inject and execute
shell code which is then prevented by the Data Execution Prevention (DEP)
mechanism.

Return Oriented Programming (ROP) is introduced together with ret2libc to
circumvent DEP. Address Space Layout Randomization (ASLR) is presented next as
counter to ROP but gets quickly broken with an information leak. StackGuard is
a more sophisticated mechanism against ROP but not a silver bullet and can be
easily brute forced in certain scenarios. Control-Flow Integrity (CFI) together
with a word about Stack Integrity is provided as an outlook for the reader.

Although x86 has been chosen as target platform a quick glance at other
architectures (x86\_64 and ARM) is taken prior concluding this writeup. Some
basics about the target platform will be communicated before running the first
exploit.

\setcounter{tocdepth}{1}
\tableofcontents

\newpage

\section*{Acknowledgement}

A university course at Rensselaer Polytechnic
Institut\footnote{\url{http://rpi.edu/}} held in Spring 2015 focused on
\textit{Modern Binary Exploitation}. They made their course material available
on GitHub \cite{rpisec} under the Creative Commons Attribution-NonCommercial
4.0 International
license\footnote{\url{https://creativecommons.org/licenses/by-nc/4.0/legalcode}}.
We reused a lot of their material in this project.

We highly recommend checking them out and having a look at their material for
further details, apart from the given references.

\section{Introduction}

Exploiting binaries was comparatively easy ten to fifteen years ago. There were
no special mitigation mechanisms in place denying even the most simplest
exploits. This is the point in time where we will start off. First we talk
about two very simple exploits, namely the format string exploit and the buffer
overflow in combination with shell code. Although there is a huge collection of
exploitation techniques known to the public, we will only look at a very small
fraction of them in this project.

The next section will communicate necessary background knowledge required to
fully grasp the two presented exploits. A short overview about the target
architecture x86 will be given.

After that, both techniques are introduced, followed by the first mitigation
technique, Data Execution Prevention (DEP). From there on we will keep on using
the buffer overflow technique with some adaptations to circumvent DEP. At that
point Return Oriented Programming (ROP) is introduced, which directly leads us
to Address Space Layout Randomization (ASLR), the follow-up mitigation
mechanism. Again, the buffer overflow can be adapted to break ASLR through the
use of additional information (info leak).

Since neither DEP nor ASLR provide significant protection against even this
simple technique, an additional mitigation has been put into place in the form
of stack cookies (StackGuard).

An outlook will be given after bypassing StackGuard by looking at Control-Flow
Integrity (CFI).

Examples will be provided along the way to support the reader and provide
additional explanations. Finally we will conclude with a word about other
architectures (x86\_64 and ARM) followed by a short recap about what has been
taught in this writeup.

\subsection{Main Assumption}

Throughout this work we assume that we know the target binary (and the used
libraries). Let us show that this assumption is quite reasonable to make by
looking through the eyes of the adversary. An attacker who wants to penetrate a
target machine would most likely choose the easiest path --- exploiting the
weakest link. Most machines relevant to an attacker's interest will provide
multiple services. Consider following scenario:

The main server of a small business company runs a homemade communication
service for interaction between them and their clients. The attacker has no
access to the source or binary of this communication service's daemon running
on the target machine. But, along with it, a commonly used web server is
listening on port 80. Getting the source (and binary) of the web server is much
easier, therefore an attacker would pick this entry point over the
communication service daemon.

\begin{listing}[h!]
    \begin{code*}{linenos=false}
        <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
        <html><head>
        <title>400 Bad Request</title>
        </head><body>
        <h1>Bad Request</h1>
        <p>Your browser sent a request that this server could not understand.<br />
        </p>
        <hr>
        <address>Apache/2.2.22 (Ubuntu) Server at ovinnik.canonical.com Port 80</address>
        </body></html>
        Connection closed by foreign host.
    \end{code*}
    \caption{A web server's response to a misspelled request}
    \label{src:http_response}
\end{listing}

\Cref{src:http_response} shows a possible response of a web server when
receiving an invalid request. The web server tells us his exact version and
since it also provides information about the operating system (distribution) an
attacker can easily mimic this setup to test and tweak his exploits. Exploits
may already be known to the public if the used version is not up-to-date. An
attacker can use, modify and build upon them.

\section{Platform x86}
\label{sec:x86}

This section will teach necessary background knowledge about the target
platform to fully conceive the following techniques. But first let us elaborate
why x86 has been chosen.

At the time these techniques (and their related mitigations) were established,
x86 was the most common computing platform. The majority of related material
found on the internet covers x86, and many techniques can be translated from
x86 to other architectures with ease.

A more detailed overview can be found on
Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/X86}} and --- if this is
not enough --- consider the Intel
Manual\footnote{\url{https://www-ssl.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html}}
for a more profound insight.

\subsection{CPU and registers}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\textwidth]{gfx/x86_registers.pdf}
    \caption{Register overview including \SI{64}{\bit} extension}
    \label{fig:registers}
\end{figure}

\Cref{fig:registers} (taken from
Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=X86&oldid=696308590\#/media/File:Table_of_x86_Registers_svg.svg}})
shows an overview of registers available on the x86 platform. While there are
dedicated registers for floating-point operations and registers with hardware
protection (segment registers) we will only focus on nine commonly used
registers.

\begin{minipage}[t]{0.4\textwidth}
    \begin{description}
        \item[\texttt{EAX}] Accumulator Register
        \item[\texttt{EBX}] Base Register
        \item[\texttt{ECX}] Counter Register
        \item[\texttt{EDX}] Data Register
        \item[\texttt{ESI}] Source Index
        \item[\texttt{EDI}] Destination Index
        \item[\texttt{EBP}] Base Pointer
        \item[\texttt{ESP}] Stack Pointer
        \item[\texttt{EIP}] Instruction Pointer
    \end{description}
\end{minipage}
\begin{minipage}[t]{0.6\textwidth}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{gfx/single_register.png}
        \caption{Addressing specific parts of a register including \SI{64}{\bit} extension}
        \label{fig:single_register}
    \end{figure}
\end{minipage}
\bigskip

The instruction pointer \texttt{EIP} points to the next instruction in memory
which will be executed on the subsequent cycle. Stack pointer \texttt{ESP} and
base pointer \texttt{EBP} are used for stack management which is vital to call
and return from multiple functions properly. The remaining six registers are
used for arithmetic and memory operations as well as passing arguments
(parameters) for system calls. Their values can either be interpreted as
integer or pointer.

Note that these registers can be addressed partially, allowing one to write
only to the lower \SI{16}{\bit}, for example, as displayed in
\cref{fig:single_register} (taken from \textit{null
programm}\footnote{\url{http://nullprogram.com/img/x86/register.png} on
December 2015}).

The CPU comes with protection mechanisms which allows the operating system's
kernel to limit other processes' privileges. This mechanism is known as
\textit{protection rings} (Ring 0 -- Ring 3). The kernel runs \emph{in} Ring 0
(most privileged) and switches to Ring 3 (least privileged) when a normal
process is scheduled. A system call is invoked by the process if it needs
anything beyond its scope. The kernel takes over, deals with the request and
returns execution back to the process. This is known as \textit{context switch}
and switching between Rings happens along with it.

\subsection{System Calls}

As already mentioned in the previous paragraph, a process only holds limited
capabilities and the kernel has to take over to fulfill certain (more
privileged) operations. The operating system's documentation tells which system
calls are available (on which platform) and what parameters each of them
requires. Let us illustrate this with an example: On x86 Linux the system call
number 4 (starting from 0) is the \texttt{sys\_write} system call which writes
data to a file descriptor. It takes three arguments, the file descriptor to
write to, a pointer to the start of the data which should be written and the
length of the data. The number of the system call, together with these three
parameters are placed in the \texttt{EAX}, \texttt{EBX}, \texttt{ECX},
\texttt{EDX} registers respectively. Following instruction is issued to invoke
the system call:

\begin{nasmcode*}{linenos=false}
    int     0x80
\end{nasmcode*}

Nowadays you may encounter a different mechanism used for system calls,
utilizing Virtual Dynamic Shared Objects (vDSO). This goes beyond our scope
here and we will use the previously mentioned mechanism in the following
exploits as they work side by side. Consult the corresponding man
page\footnote{\url{http://man7.org/linux/man-pages/man7/vdso.7.html}} for
further reading.

\subsection{Memory}

Physical memory is managed by the kernel through the use of a Memory Management
Unit (MMU). Each process' address space is virtualized and memory operations
are translated on-the-fly by the MMU. Physical memory is segmented into
\textit{pages} (typically \SI{4}{\kibi\byte} in size) and each page can be
\emph{mapped into} the virtual address space of one or more (shared page)
processes.~\cite[pp.~400]{unix_interals}

The main parts located inside the (virtual) address space of a process are the
executable itself with its \texttt{.text} and \texttt{.data} section, the heap
(used for dynamic data), the stack (used for local variables and function
calling) and libraries.

\subsection{Endianness}
\label{sub:endianness}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{gfx/little_endian.pdf}
    \caption{Byte order in little-endian}
    \label{fig:little_endian}
\end{figure}

Endianness refers to the byte order used when storing data in memory (or
transmitting it over the network). x86 uses little-endian which is described in
\cref{fig:little_endian} (taken from
Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=Endianness&oldid=696417697\#/media/File:Little-Endian.svg}}).
The least significant byte of a word is placed at the lower memory address and
successive bytes are placed as the memory address increases. The related
Wikipedia page\footnote{\url{https://en.wikipedia.org/wiki/Endianness}} goes
into more detail about this --- more than currently needed. We will later refer
back to this when swapping bytes because of endianness.

\subsection{Calling Convention}
\label{sub:calling_convention}

A calling convention defines how function calls should be implemented. What
calling convention is used depends on the platform, toolchain and compiler
settings. Let us exhibit what the convention defines and what convention we are
using (cdecl).

\begin{minipage}[t]{0.48\textwidth}
    Convention defines:
    \begin{itemize}
        \item Where to place arguments
        \item Where to place return value
        \item Where to place return address
        \item Who prepares the stack
        \item Who saves which register
        \item Who cleans up\\
            (caller or callee)
    \end{itemize}
\end{minipage}\hfill
\begin{minipage}[t]{0.48\textwidth}
    C Declaration (cdecl):
    \begin{itemize}
        \item Arguments on stack (reverse order)\\
            stack aligned to \SI{16}{\byte} boundary
        \item Return via register (\texttt{EAX} / \texttt{ST0})
        \item \texttt{EAX}, \texttt{ECX}, \texttt{EDX} saved by the caller\\
            rest saved by the callee
        \item On stack:\\
            old instruction pointer (\texttt{IP})\\
            old base pointer (\texttt{BP})
        \item Caller does the cleanup
    \end{itemize}
\end{minipage}

\section{Format String Exploits}
\label{sec:format_string_exploit}

The first exploitation technique we will discuss builds upon the interpretation
of format strings. \texttt{printf} is a C function of the standard library
which will interpret such strings and print them to \texttt{stdout}. As the
name already tells you, the supplied string contains \textit{formatter}
describing how to handle additional arguments. If you are unfamiliar with
\texttt{printf} please have a look at the man
page\footnote{\url{http://linux.die.net/man/3/printf}} now.

Taking a closer look at \texttt{printf} we can see that its first argument is a
format string followed by a variable number of additional arguments. A common
implementation, together with a small example, of this is described in the man
page\footnote{\url{http://linux.die.net/man/3/stdarg}} of \texttt{stdarg.h}.
\texttt{printf} trusts the programmer that the number of arguments supplied is
equal (or greater) than the number of formatters. Calling \texttt{printf} with
the format string \texttt{"\%d + \%d = \%d"}, for instance, assumes that (at
least) three additional arguments are given.

\begin{listing}[h!]
    \begin{minipage}[t]{0.4\textwidth}
        \cfile{../src/format_string/format.c}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.5\textwidth}
        \begin{code*}{linenos=false}
            > gcc -o format format.c


            > echo foobar | ./main
            You entered:
            foobar


            > echo AAAABBBB | ./main
            correct


            > echo '%08x' | ./main
            You entered:
            bfd98ed4
        \end{code*}
    \end{minipage}
    \caption{Program vulnerable to format string exploits}
    \label{src:format_string_exploit}
\end{listing}

The exploit comes from the notion that a format string provided by an attacker
gets interpreted. The program shown in \cref{src:format_string_exploit} will
take an arbitrary string from \texttt{stdin} and pass it on to \texttt{printf}.
For simple inputs (not containing formatters) this works fine. But as soon as
formatters are provided, \texttt{printf} accesses the locations where the
corresponding arguments \emph{would} be located. From the calling convention
described in \cref{sub:calling_convention} we know that these arguments
\emph{would} be located on the stack, therefore \texttt{printf} will print
whatever lies on the stack at these positions instead.

An attacker in this scenario wants to get a hold of the hardcoded password
stored in \texttt{passwd}. Since local variables are placed on the stack
\texttt{printf} will be able to read the password if enough formatters are
provided:

\begin{code*}{linenos=false}
    > python -c 'print "%08x." * 10' | ./main
    bf920c14.00000064.b77de29e.00000000.00000000.b77fedf8.bf920d94.00000000.41414141.42424242.
\end{code*}

Here we use Python to craft the format string containing ten identifiers for
us. As we can see the password is printed (ASCII encoded). Byte order is
swapped because of endianness (see \cref{sub:endianness}). Apart from the
password we also gather a bunch of pointers, these can be used later on to
break ASLR (see \cref{sub:info_leak}).

We would like to point the reader to the book \textit{Hacking: The Art of
Exploitation}~\cite[pp.~167]{art_of_exploitation} for more details about this
and similar techniques. We will come back to this technique later on to show
that \texttt{printf} enables even more sophisticated attacks (see
\cref{sub:printbf}).

\section{Buffer Overflow}
\label{sec:buffer_overflow}

The second type of exploits we'll look at is known as buffer overflows and as
on may already derive from the name, this is about submitting more data to a
buffer than it was originally designed for. This setup can be exploited when
bound checking is done wrong or not at all. An attacker is therefore able to
overwrite memory behind the buffer's location.

\subsection{Disabling Mitigations}

The three mitigation mechanisms DEP, ASLR and StackGuard are enabled by default
nowadays, but, as mentioned in the introduction, we start off at a point where
these mechanisms were not yet in place. So to run the provided examples we
first have to disable them. DEP and StackGuard can be disabled via compiler
flags to the extend necessary using \texttt{-z execstack} and
\texttt{-fno-stack-protector} respectively.

ASLR can be disabled globally so that \emph{new} processes have an unscrambled
memory layout:

\begin{code*}{linenos=false}
    > echo 0 > /proc/sys/kernel/randomize_va_space
\end{code*}

Writing \texttt{2} instead of \texttt{0} will switch ASLR back to its default
state. Root privileges are, of course, required for this. There is also another
way by using \texttt{setarch} to run a binary:

\begin{code*}{linenos=false}
    > setarch `arch` -R ./binary
\end{code*}

\subsection{The Exploit}

The consequences of an exploited buffer overflow depend on where the buffer is
located. The most interesting location would of course be the stack because,
apart from local variables and arguments, it holds the return address of a
function. But buffers located inside the heap or static may also be viable
options. Common terms related to these scenarios are \textit{stack smashing}
and \textit{heap corruption}. For now we focus our attention on stack smashing.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{gfx/stack_smash.png}
    \caption{Stack frame containing a buffer}
    \label{fig:stack_frame}
\end{figure}

Let's start off by examining the stack containing a buffer \texttt{c} as local
variable, see \cref{fig:stack_frame}. Right now the buffer holds the string
\texttt{"hello"} followed by a terminator. Since it has been allocated to hold
a maximum of \SI{12}{\byte} this fits. If data larger than \SI{12}{\byte} is
written to the buffer, the following variable (or parameter) \texttt{bar} will
be overwritten, followed by the saved frame pointer and the return address. If
even more data is supplied the adjacent stack frame will be overwritten in the
same manner.

If an attacker can provide the data written to the buffer and no (or wrong)
bound checking is done, he is able to inject arbitrary (malicious) code into
the stack frame. This could, for instance, be used to overwrite a flag
indication whether an authentication has been performed successfully or not.
But since this is pretty forward let's go beyond that and see what happens when
changing the return address.

\begin{listing}[h!]
    \begin{minipage}[t]{0.37\textwidth}
        \cfile{../src/buffer_overflow/overflow.c}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.63\textwidth}
        \codefile{../src/buffer_overflow/overflow_objdump.txt}
    \end{minipage}
    \caption{Program vulnerable to buffer overflows}
    \label{src:buffer_overflow}
\end{listing}

As shown in \cref{src:buffer_overflow} we have a buffer suited for
\SI{20}{\byte} but without any bound checking. If the provided input is longer,
it will overwrite the return address. Let's have a look at the resulting binary
utilizing \texttt{objdump}.

Looking at lines 13 and 23 we can infer that the buffer will start
\SI{28}{\byte} (\texttt{0x1c}) before the base pointer. Hence we have to supply
\SI{32}{\byte} (28 + 4) of arbitrary data followed by the address where we want
to jump to. Let's jump into the function \texttt{mordor} located at
\texttt{0x804849b}, keep in mind that the byte order needs to be swapped.

\begin{code*}{linenos=false}
> python -c "print 'A'*32 + '\x9b\x84\x04\x08'" | setarch `arch` -R ./overflow
Enter text:
You entered: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��
One does not simply jump into mordor()!
Segmentation fault (core dumped)
\end{code*}

\texttt{mordor} has been executed successfully. Despite the segmentation fault
one can see that the return address has been overwritten successfully.

\section{Shell Code}

While this is neat and can certainly be useful to an adversary, stack smashing
also enables us to inject arbitrary code into a program. Contrary to the
previous section the target machine will execute code provided by the attacker.
This can be achieved by bending the return address into the buffer used for the
exploit. Provided instructions will be executed upon return. Shell code is a
piece of (binary) code which opens up a shell that reads and executes commands
from an attacker. This example is taken from Dhaval Kapil's
blog\footnote{\url{https://dhavalkapil.com/blogs/Shellcode-Injection/} on
December 2015} there is also a section about this in \textit{Hacking: The Art
of Exploitation}~\cite[pp.~281]{art_of_exploitation}.

A more com comprehensive article \cite{phrack_stack_smash} about Stack Smashing
is available on \texttt{phrack}\footnote{\url{http://phrack.org/}}.

\subsection{Crafting Shell Code}

\begin{listing}[h!]
    \begin{minipage}[t]{0.4\textwidth}
        \nasmfile{../src/shell_code/shellcode.asm}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.5\textwidth}
        \codefile{../src/shell_code/shellcode_objdump.txt}
    \end{minipage}
    \caption{Assembly code opening up a shell upon execution}
    \label{src:shell_code}
\end{listing}

The piece of assembly shown in \cref{src:shell_code} sets up the parameters for
the \texttt{execve} system call and then invokes it to replace the currently
running process with a shell. \texttt{execve} takes three arguments, a string
of the program to execute (here \texttt{"/bin//sh"} + terminator), a list of
arguments for that program and a list of environment variables. The
corresponding system call number is 11 and \texttt{NULL} will be accepted for
both lists. The double slash in the first argument is used to prevent null
bytes inside the shell code. The function which reads the shell code may
truncate it upon reading a null byte, therefore we have to work around this
without changing the underlying semantics.

Running this code through an assembler yields binary code, shown in
\cref{src:shell_code}, which will be part of the payload.

\begin{code*}{linenos=false}
    \x31\xC0\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\x50\x89\xE2\x53\x89\xE1\xB0\x0B\xCD\x80
\end{code*}

\subsection{Examining the Target Binary}

We'll examine the target binary in a debugger (\cref{src:shell_code2}) to find
the starting location of our buffer.

\begin{listing}[h!]
    \begin{minipage}[t]{0.4\textwidth}
        \cfile{../src/shell_code/vuln.c}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.5\textwidth}
        \codefile{../src/shell_code/vuln_gdb.txt}
    \end{minipage}
    \caption{Examining the target binary in \texttt{gdb}}
    \label{src:shell_code2}
\end{listing}

Now we know that the buffer will be located at \texttt{0xbffff4bc} (saved base
pointer will be at \texttt{0xbffff528}) at runtime, but it may be offset a few
bytes when run without a debugger. This happens because environment variables
and meta information, like the program name, determine the stack starting
position (stack is placed right before environment variables). Hence we may not
hit the first instruction of our shell code right away, but since the buffer is
bigger than the actual payload we can improve our odds by prefixing the shell
code with \texttt{NOP} instructions. As long as the return address points
somewhere into this sequence of \texttt{NOP}s the CPU will \emph{slide} to the
first instruction of the shell code. Therefore this is known as a
\textit{\texttt{NOP} Sled}. We append some arbitrary data to the shell code as
offset to overwrite the return address. This is also illustrated in
\cref{fig:shell_code} where \textit{target} is the new return address supplied
by the attacker. Using the maximum amount of \texttt{NOP}s possible would also
be a viable option, here we just went with the original example.

\begin{figure}[H]
    \centering
    \input{gfx/shellcode.tikz}
    \caption{Putting the payload together}
    \label{fig:shell_code}
\end{figure}

Let's first calculate the distance between the start of the buffer and the
return address. The return address will be located \SI{4}{\byte} after the
saved base pointer location.

\[(\texttt{0xbffff528} + 4) - \texttt{0xbffff4bc} = 112\]

We prefix our shell code with a \texttt{NOP} Sled consisting of \SI{40}{\byte}
(opcode for \texttt{NOP} is \texttt{0x90}). Since our shell code is \SI{25}{\byte}
long we add 47 \texttt{'A'}s to gap the remaining distance. Lastly we have to add
the new return address which should point to the \texttt{NOP} Sled's center.

\[\texttt{0xbffff4bc} + 20 = \texttt{0xbffff4d0}\]

\subsection{Gimme that Shell already}

\codefile[linenos=false]{../src/shell_code/run.txt}

After injecting the payload we get a few lines of garbage and receive a prompt
by hitting return a few times. You can enter commands and receive output like
usual.

\section{Data Execution Prevention (DEP)}

The first mitigation technique discussed, DEP, is also known under the term
\textit{write XOR execute (\texttt{w\^{}x})} and it will prevent us from
executing injected code like we did in the shell code example previously. This
happens by attaching an execute flag to each page (in addition to the read /
write flags). If the instruction pointer points to a page without the execute
flag set, a segmentation fault will be triggered. The only pages flagged for
execution are the ones that belong either to the \texttt{.text} segment or to
used libraries (by default) since they will contain the program code. The stack
is (of course) not executable by default. Therefore our shell code example
would simply segfault.

The execution flag is enforced by hardware on modern platforms. But for CPUs
that lack such hardware support, software-enforced DEP provides limited
protection.~\cite{wiki:dep}

Previously we worked around this by passing \texttt{-z execstack} to the
compiler, hence data on the stack was executable. This can also be seen in the
output of \texttt{readelf}.

\begin{listing}[h!]
    \codefile{../src/shell_code/vuln_readelf.txt}
    \caption{\texttt{readelf} output with and without \texttt{-z execstack}}
    \label{src:dep_readelf}
\end{listing}

\begin{listing}[h!]
    \codefile{../src/shell_code/run_dep.txt}
    \caption{Running the shell code example without \texttt{-z execstack}}
    \label{src:dep_shell_code}
\end{listing}

\Cref{src:dep_readelf} shows that with \texttt{-z execstack} the stack section
is marked (looking at \texttt{Flg} in lines 8 and 19) with execute
(\texttt{E}). Running the example, see \cref{src:dep_shell_code}, yields the
segfault described in the previous paragraphs. The program is terminated upon
receiving the segfault.

DEP makes injecting arbitrary code into binary much harder, but we still
control the return address --- so let's use it.

\section{Return Oriented Programming (ROP)}

The first example shown in the \cref{sec:buffer_overflow} already illustrated
the power that comes along with controlling the return address. It enabled us
to jump to a completely different function upon execution. The target binary
may not contain a function doing exactly what an attacker wants to do. But by
controlling the return address one can build a, so called, \textit{ROP chain}
to execute (more or less) arbitrary code, which is made out of
\textit{gadgets}.~\cite{wiki:rop,buchanan2008good,shacham2007}

\subsection{Gadgets}

A gadget is a, usually short, sequence of instructions ending with a
\texttt{ret} instruction.

An attacker scavenges the target binary (and used libraries) for such sequences
in order to combine them to build a new, malicious sequence of instructions.
The size and diversity of the code base dictates the diversity of available
gadgets and therefore the difficulty of building a specific sequence.

The shell code used in this paper could be mapped to three gadgets, for
example. The first one pushes the string \texttt{"/bin//sh"} onto the stack,
the second one sets up the registers (arguments) and the last one calls the
\texttt{execve} system call.

The final \texttt{ret} statement of a gadgets is required for chaining them
together. We not only use the buffer overflow to control \emph{one}, but
\emph{multiple} return addresses. Because of this our payload will be composed
of a list of return addresses (the start of each gadgets) interleaved by some
padding. Each provided address will be consumed one by one at the end of each
gadgets to \emph{jump} to the next one. The payload may still contain data like
\texttt{"/bin//sh"} if necessary.

\begin{listing}[h!]
    \codefile{../src/return_oriented_programming/gadgets.txt}
    \caption{Finding available gadgets in a binary}
    \label{src:rop_gadgets}
\end{listing}

One can easily get a list of available gadgets by piping the output of
\texttt{objdump} to \texttt{grep} filtering for \texttt{ret} instructions. This
is done in \cref{src:rop_gadgets} where three different gadgets can be
observed. Of course each gadget can be arbitrary long, we just used a length of
5 instructions in this example.

There are algorithms and tools available which simplify the process of finding
such gadgets (and even whole chains) but they go beyond the scope of this
writing.~\cite{shacham2007}

\subsection{Example}

This example is taken from a blog
post\footnote{\url{http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html}}
on Code Arcana, which also includes a simpler as well as a more complex example
about ROP.

\begin{listing}[h!]
    \begin{minipage}[t]{0.4\textwidth}
        \cfile{../src/return_oriented_programming/rop.c}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.6\textwidth}
        \codefile[breaklines]{../src/return_oriented_programming/run.txt}
    \end{minipage}
    \caption{Example for exploiting a Buffer Overflow with ROP}
    \label{src:rop_example}
\end{listing}

The target program is displayed in \cref{src:rop_example}. We will not be able
to inject and execute shell code --- and there is no function present which
directly opens up a shell for us. But there are parts which can be glued
together to do so.

On the right hand side we see the execution of the exploit. First note that we
no longer compile with \texttt{-z execstack}. We read the locations of
\texttt{not\_used} and \texttt{system} via \texttt{gdb} and note down the
corresponding addresses. \texttt{objdump} is used to have a quick glance at the
generated binary code for \texttt{vulnerable\_function} and note down the
distance between the saved base pointer the start of the buffer too (line 17).

Following payload can be established with the gathered information: Starting
with some \texttt{'A'}s to fill the buffer followed by 4 \texttt{'B'}s to
overwrite the saved base pointer. The next part is new, we attach the address
of \texttt{system} followed by some padding and a pointer to
\texttt{not\_used}.

We happily receive a shell upon running the exploit. Execution will be handed
back to the original binary after we close the shell. Since we messed up the
control-flow with our exploit the program segfaults shortly after.

This is also described as \textit{ret2libc} since we used ROP to jump to a
function (\texttt{system}) provided by libc.

\section{Address Space Layout Randomization (ASLR)}

This mitigation technique was introduced to render ROP (and ret2libc) void. The
idea behind it is quite simple, and the name gives it away already. Memory
layout is randomize so an attacker cannot reliably use ROP. An attacker will
not be able to copy the exact setup of a target machine by only knowing which
binary (and libraries) is used.

\begin{listing}[h!]
    \begin{code}
        > echo 2 > /proc/sys/kernel/randomize_va_space

        > cat /proc/self/maps
        08048000-08054000 r-xp 00000000 08:01 131085     /bin/cat
        08054000-08055000 r--p 0000b000 08:01 131085     /bin/cat
        08055000-08056000 rw-p 0000c000 08:01 131085     /bin/cat
        091de000-091ff000 rw-p 00000000 00:00 0          [heap]
        b7531000-b76e5000 r-xp 00000000 08:01 917531     /lib/i386-linux-gnu/libc-2.21.so
        b76f7000-b7719000 r-xp 00000000 08:01 917507     /lib/i386-linux-gnu/ld-2.21.so
        bfe0d000-bfe2e000 rw-p 00000000 00:00 0          [stack]

        > cat /proc/self/maps
        08048000-08054000 r-xp 00000000 08:01 131085     /bin/cat
        08054000-08055000 r--p 0000b000 08:01 131085     /bin/cat
        08055000-08056000 rw-p 0000c000 08:01 131085     /bin/cat
        093e3000-09404000 rw-p 00000000 00:00 0          [heap]
        b7560000-b7714000 r-xp 00000000 08:01 917531     /lib/i386-linux-gnu/libc-2.21.so
        b7726000-b7748000 r-xp 00000000 08:01 917507     /lib/i386-linux-gnu/ld-2.21.so
        bf962000-bf983000 rw-p 00000000 00:00 0          [stack]

        > cat /proc/self/maps
        08048000-08054000 r-xp 00000000 08:01 131085     /bin/cat
        08054000-08055000 r--p 0000b000 08:01 131085     /bin/cat
        08055000-08056000 rw-p 0000c000 08:01 131085     /bin/cat
        094ec000-0950d000 rw-p 00000000 00:00 0          [heap]
        b7588000-b773c000 r-xp 00000000 08:01 917531     /lib/i386-linux-gnu/libc-2.21.so
        b774e000-b7770000 r-xp 00000000 08:01 917507     /lib/i386-linux-gnu/ld-2.21.so
        bfb24000-bfb45000 rw-p 00000000 00:00 0          [stack]
    \end{code}
    \caption{Let \texttt{cat} show its memory mappings with ASLR enabled (some
lines have been omitted)}
    \label{src:aslr_cat}
\end{listing}

ASLR is enabled by default and one can easily check the implications by running
\texttt{cat} on \texttt{/proc/self/maps} a few times as shown in
\cref{src:aslr_cat}. Line 10, 19 and 28 show, for example, that the stack
starts at different locations in memory each time cat is invoked.

We can directly see one flaw in this setup --- not all sections of the
\texttt{cat} binary start at random locations. Especially the \texttt{.text}
always starts at the same position. This happens because \texttt{cat} itself
was not compiled as a Position Independent Executable (PIE). Since this is
actually the default of \texttt{gcc}, most programs' \texttt{.text} segment
will always start at the same location. One could pass the corresponding flag
(\texttt{-pie}) to the compiler to prevent this, so ASLR would be able to
randomize these segments too, but you'd have to compile every relevant package
again instead of using the distribution vendor's pre-compiled binary.

Breaking ASLR, even when the code is compiled with \texttt{-pie}, is easier
than it seems at first. Relocation only happens to a section as a whole,
functions inside a section still share the same relative distance as they would
without ASLR. But before exploit this fact, have a look at the randomized
addresses again.

Only three nybble ($3 \times \SI{4}{\bit}$) differ between multiple runs giving
us $2^{12} = 4096$ possibilities. If the scenario allows it, brute forcing
would be a viable option here. But note that this changes drastically for
\SI{64}{\bit}. But we won't hassle with brute force, a better option has
already been teased.

\subsection{Info Leak}
\label{sub:info_leak}

ASLR can be broken easily as soon as \emph{one} pointer to a section of
interest gets \emph{leaked}. Therefore the name information leak. We show the
implications of such a leak by an example taken from \cite{rpisec}.

\begin{quote}
    Lets say you managed to leak a pointer (\texttt{0xb7e72280}) and you know
    that this one usually points to \texttt{printf}.
    \medskip

    Look how far away \texttt{system} is from \texttt{printf}, in the standard
    library. It's \texttt{0xd0f0} bytes.
    \medskip

    We now know that \texttt{system} is at:
    \[ \mathtt{0xb7e72280} - \mathtt{0xd0f0} = \mathtt{0xb7e65190} \]
\end{quote}

In case you may wonder how easy it is to leak a pointer, this already happened
to us as a side effect in the format string example
(\cref{sec:format_string_exploit}).

Our previous exploit can be adapted as follows. First, manage to leak a pointer
somehow, which enables you to calculate the address offset introduced by ASLR.
Augment your ROP chain to take the offset into account. Run the exploit. Since
this is rather simple and we already gave an example how to calculate the
offset, we would like to leave this as an exercise for the reader.

Manipulate the target source code used in the ROP example to print the address
of \texttt{printf} first, \emph{then} read in the payload via \texttt{stdin}.
This way you can first simulate a leaked pointer, adapt the ROP chain and run
it. Double check the distances between library functions, they may differ with
the ones used in our example.

\section{StackGuard}

DEP can be fooled by ROP and ASLR is rendered useless with a simple info leak.
Something else is required at this point. Thinking back, the original problem
emerged from manipulating the return address located on the stack. Two
(additional) counter mechanisms were introduced going by the names of
StackGuard and StackShield. We will take only a look at StackGuard and one
relatively common scenario to break it, but there is a comprehensive article
\cite{phrack_stack_guard} on \texttt{phrack}\footnote{\url{http://phrack.org/}}
describing and breaking both mechanisms.

The general idea behind StackGuard is to place \emph{something} before the
return address which \emph{guards} against overwriting the return address via a
buffer overflow. This \emph{something} is known as a canary and comes in
different forms.

\begin{description}
    \item[Terminator] A terminator canary contains a sequence of commonly used
        terminator symbols (like null, EOF, linefeed, \dots) to
        \emph{terminate} \emph{most} string operations before they would change
        the return address.

    \item[Random] A random canary is chosen at program start, stored
        \textit{somewhere save} and pushed onto the stack upon function calls.
        The canary on the stack is compared with the one stored save before
        executing the return instruction. The program is terminated on
        mismatch. With this setup an attacker has to know the canary in order
        to overwrite the return address via a buffer overflow. Since it is
        picked at random during program start, an attacker cannot reliably
        reproduce the same canary in his cloned setup.

        In our case the original canary will be stored in one of the segment
        registers\footnote{\url{https://en.wikipedia.org/w/index.php?title=X86_memory_segmentation&oldid=697253060}
        see \textit{Later developments}}.
\end{description}

There is also the random XOR canary which XORs the (stored) random canary with
the return address before placing it on the stack. ``This is effectively
encryption of the return address with the random canary of this
function.''~\cite{phrack_stack_guard}

The practical approach is taken next by looking at the stack frame of a
vulnerable function when compiled without \texttt{-fno\_stack\_protector}.

\begin{listing}[h!]
    \begin{minipage}[t]{0.32\textwidth}
        \cfile{../src/canary/vuln.c}
    \end{minipage}
    \begin{minipage}[t]{0.33\textwidth}
        \codefile{../src/canary/vuln_gdb1.txt}
    \end{minipage}
    \begin{minipage}[t]{0.33\textwidth}
        \codefile{../src/canary/vuln_gdb2.txt}
    \end{minipage}
    \caption{Examining the canary as generated by GCC}
    \label{src:canary_gcc}
\end{listing}

As can be seen in \cref{src:canary_gcc} the buffer was not filled beyond its
capacity to examine the canary located in the same stack frame. A script
created by Daniel Walter\footnote{\url{http://0x90.at/post/gdb-stack-script}}
has been adapted slightly to display the stack together with some annotations.
Using \texttt{"AAAAAAA\textbackslash{}n"} and
\texttt{"BBBBBBB\textbackslash{}n"} makes the buffer clearly visible in lines
16 and 17. The canary can be observed in line 18.

The canary itself is composed of a terminator (null) followed by a random
sequence of \SI{3}{\byte}. This sequence changes every time the program is run.
Feeding more data to the buffer and overflowing it this way yields termination
of the program. Note that \texttt{puts} is still executed, the termination
happens just before the return of \texttt{fun}.

\begin{code*}{linenos=false}
    > echo AAAAAAAADEADBEEF | ./vuln
    AAAAAAAADEADBEEF

    *** stack smashing detected ***: ./vuln terminated
    Aborted (core dumped)
\end{code*}

\subsection{Server-Worker Paradigm}

Of course there are multiple paths available when trying to break the
StackGuard mechanism, as mentioned in \cite{phrack_stack_guard}. We will now
have a look at the common server-worker paradigm. \Cref{src:server_worker}
shows how that paradigm looks like from a task monitor's view. The server /
daemon (here \texttt{apache2}) is started with root privileges in order to
listen on a \textit{privileged} port. After the initialization has been
compiled, the server forks itself multiple times to create a set of workers. In
this example the workers drop their root privileges right away by changing
their current user to \texttt{www-data}. But our focus is not on the privileges
but the problem introduced by fork with respect to the StackGuard.

\begin{listing}[h!]
    \codefile[linenos=false]{gfx/server_worker.txt}
    \caption{Server worker paradigm from the view of a task monitor}
    \label{src:server_worker}
\end{listing}

Many things are copied\footnote{Actually referenced utilizing a copy-on-write
method} over to the new process when using \texttt{fork}. The canary is copied
too (more details at \cite{phrack_stack_guard2}). Together with the
fact\footnote{We assume that the server wants to maintain a maximum of
availability} that the server will fork itself again if one of its workers dies
or crashes to keep the worker pool at its configured sized.

An attacker will be able to guess the \emph{same} canary multiple times since
the server will keep spawning workers if they crash --- even due to a stack
smash. The attacker receives information about whether his guess was correct or
not by whether his connection has been terminated. And now to the meat of this
method.

Have a look at \cref{src:canary_gcc} again and reexamine the canary. While
occupying \SI{4}{\byte} only 3 of them are random --- first byte acts as a
terminator. We have already seen via previous examples that a buffer overflow
often allows writing to consecutive memory \emph{byte by byte}. Putting this
information together yields following upper bound for brute forcing a canary in
the described scenario:

\begin{align*}
    \implies 2^8 \times 3 & = 768  & \text{ guesses at most on \SI{32}{\bit}}\\
    \implies 2^8 \times 7 & = 1792 & \text{ guesses at most on \SI{64}{\bit}}
\end{align*}

Again, this is just \emph{one} of many different ways to work around the
StackGuard mechanism. Depending on your operating system's and compiler's
implementation this may or may not work. We encourage the reader to try this
technique locally with a minimal example. Running the exploit multiple times
and recording the runtime (number of guesses) may be of interest.

\section{Control-Flow Integrity (CFI)}

In this section we are going to have a short glimpse at Control-Flow Integrity,
but before that we need to talk about the Control-Flow Graph (CFG).

\subsection{Control-Flow Graph (CFG)}

Again the name already tells you what this is about, a directed graph that
reflects the control-flow of a program. Different definitions exist regarding
what is actually used to compose a node and anchor them together. In our case
we will create a node out of each function and connect them at function calls.

\begin{figure}[H]
    \centering
    \input{gfx/control_flow_graph.tikz}
    \caption{Control-flow graph example}
    \label{fig:cfg}
\end{figure}

\Cref{fig:cfg} shows an example of such a graph. From it one can tell that
\texttt{funB} will be called from \texttt{funA} and \texttt{funE} but not, for
instance, from \texttt{funD}. This is all we care about right now. Note that
contrary to some definitions this graph is not acyclic since we also model
direct and indirect recursion as can be seen by $\texttt{funC} \to
\texttt{funC}$ and $\texttt{funcB} \to \texttt{funcD} \to \texttt{funcE} \to
\texttt{funcB}$ respectively.

\subsection{Back to CFI}

CFI is a big topic and, like other topics already mentioned, goes beyond the
scope of this writeup. The first pointer we hand the reader aims at the
corresponding
section\footnote{\url{http://clang.llvm.org/docs/ControlFlowIntegrity.html}} of
the Clang documentation, but we recommend checking out the related research
paper \cite{ms_cfi} for more information. A more accessible and recent way to
this topic may be the
talk\footnote{\url{https://www.youtube.com/watch?v=FA0VK7s5tSQ}} \textit{New
memory corruption attacks: why can't we have nice things?} given by gannimo
(Mathias Payer).

The CFG has already been established, now let's see how it can be used to
counter the buffer overflow return address dilemma. At compile-time the graph
is available and can be used to create additional constraints which the program
must obey during runtime. This is similar to the StackGuard mechanism where we
attach code to the end of a function which checks if the canary is still
intact. But now we don't check for a canary but for the validity of the return
address directly. From the CFG we can build a set of possible return targets
for each function. Looking back at the example shown in \cref{fig:cfg} we can
determine that \texttt{funB} returns either to \texttt{funA} or \texttt{funE}.
The corresponding addresses are put into this set which is then stored in the
binary. Before \texttt{funB} returns the return address on the stack is
compared to the entries listed in the corresponding set. If no match is found,
the program terminates.

With this mechanism set up, one can easily see that it is no longer possible to
chain \emph{arbitrary} gadgets together to pull off ROP. But we still control
the return address and can jump to different locations as long as we stick to
the CFG. Each transition from one node to another has to be valid, while the
overall path taking by our ROP chain may do things never intended by the
program's author. This concept is known as control-flow bending.~
\cite{cf_bending}

\subsection{Stack Integrity}

Using a changed return address is what ultimately enables control-flow bending.
Stack integrity ensures that the same return address is used upon executing the
\texttt{ret} instruction as was pushed upon that very function call. This can
be achieved by using a \textit{shadow-stack} similar to the StackShield
mechanism but we suggest reading about \textit{Code-Pointer Integrity (CPI)}
\cite{cpi} regarding this topic.

\subsection{There is an interpreter in your C}
\label{sub:printbf}

We conclude this section by mentioning the availability of an interpreter
(probably) available in your standard library. As presented by gannimo,
\texttt{printf} is far more capable than just printing arguments. It is also
possible to read and \emph{write} to memory locations. But one can go even
further and craft a format string mimicking each of the eight operators of
Brainfuck\footnote{\url{https://en.wikipedia.org/wiki/Brainfuck}}. Because
Brainfuck is Turing complete we can deduce that \texttt{printf} is a Turing
complete interpreter. Note that this requires \texttt{printf} to be called in a
loop and the format strings may depend heavily on your library's
implementation. (Also not all implementation are Turing complete).

A compiler accepting Brainfuck and spitting out the corresponding format
strings, including examples, can be found on HexHive's
GitHub\footnote{\url{https://github.com/HexHive/printbf}}.

\section{Other Architectures}

We have already reasoned about why x86 was the platform chosen for all this in
\cref{sec:x86}, but now we'll have a short look at two other common platforms.
Most of this is directly taken from \cite{rpisec} with some smaller additions.

On x86 instructions range from \SIrange{1}{15}{\byte} and one can even bend the
instruction pointer between instructions to yield a completely different
execution than originally available.

\subsection{x86\_64}

x86\_64, also known as x64 and AMD64, is, at its core, a \SI{64}{\bit}
extension to x86 which already replaced a lot of x86 machines. Its general
purpose registers are \SI{64}{\bit} wide and there are eight more of them.

We will find the most interesting difference in the calling convention,
\textit{fastcall}, where (the first few) arguments are passed via registers
instead of pushing them onto the stack. This makes ROP much easier.

Contrary, breaking ASLR by brute force gets much harder since the address space
is \emph{much} bigger which yields more entropy for the randomization. Similar
techniques like \textit{heap spraying} are basically useless, but we can still
resort to the info leak. Breaking a canary via brute force gets only a little
bit harder, but this has already been shown in an example.

\subsection{ARM}

ARM CPUs will be encountered mostly in portable, low-power oriented devices
such as smart phones and tables, but are also found in embedded devices like
routers. They consist of a \SI{32}{\bit} RISC instruction set with a
\SI{16}{\bit} mode (known as THUMB mode). The used calling convention is
basically the same as under x86\_64 (fastcall), arguments are passed via
registers.

Compared to the previous both, ARM has a \SI{4}{\byte} instruction alignment
(\SI{2}{\byte} under THUMB).

A heads up about caching: on ARM cache has to be flushed manually (or via large
memory operations).

\section{Conclusion}

Starting with no mitigation mechanisms in place, we have seen how easy it is to
manipulate the program by exploiting just one simple buffer overflow. Going
beyond simple manipulations like changing locale variables, we craft shell code
and injected it to open up a shell accepting and executing arbitrary inputs.
Next, Data Execution Prevention (DEP) was presented to deny the ability of
\emph{injecting} new code.

This was countered by introducing Return Oriented Programming (ROP) (and
ret2libc) which removes the requirement of injecting new code to exploit a
binary. This is done by combining code fragments (gadgets) already available in
the target binary and libraries to build new, malicious sequences of
instructions.

Address Space Layout Randomization (ASLR) was established to prevent ROP but
can be defeated with an information leak. Even the StackGuard mechanism can be
broking with brute force (including an unexpected low upper bound) in certain
scenarios.

The basic idea behind Control-Flow Integrity (CFI) was communicated after that
followed by a small glance at \texttt{printf}'s capabilities to work as an
interpreter. Along the way references and various outlooks have been provided
to aid the reader.

Before concluding with this section a short word about other architectures and
their implications on the presented techniques has been given,

Happy Hacking

\newpage

\bibliography{references}

\end{document}
